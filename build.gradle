import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

import static org.apache.tools.ant.taskdefs.condition.Os.*

apply plugin: 'java'
sourceCompatibility = 1.9

def envJavaHome = System.getenv("JDK_HOME")
if (envJavaHome == null || envJavaHome.equals("")) envJavaHome = System.getenv("JAVA_HOME")
def javaHome = envJavaHome == null || envJavaHome.equals("") ? System.getProperty("java.home") : envJavaHome
def javaHomeFile = file(javaHome)
defineProperty("JDK_HOME",
        javaHomeFile.name == "jre" ?
                javaHomeFile.getParent().toString() :
                javaHomeFile.name.startsWith("jre") ?
                        new File(javaHomeFile.getParent(), "jdk1.${javaHomeFile.name.substring(3)}.0").toString() :
                        javaHome) // we have to bail and set it to something and this is as good as any!
ext.JAVA_HOME = JDK_HOME
defineProperty("CONF", "Debug")
defineProperty("JAVA", "$JDK_HOME/bin/java")
defineProperty("RETAIN_PACKAGER_TESTS", "false")
defineProperty("TEST_PACKAGER_DMG", "false")
defineProperty("FULL_TEST", "true")
defineProperty("JDK_JMODS", System.getenv("JDK_JMODS") ?: System.getenv("JDK_HOME") + "/jmods")
defineProperty("IS_DEBUG_NATIVE", "false")
defineProperty("PRODUCT_NAME", "OpenJFX")
defineProperty("COMPANY_NAME", "N/A")
defineProperty("PLATFORM_NAME", "Platform")
ext.IS_MAC = OS_NAME.contains("mac") || OS_NAME.contains("darwin")
ext.IS_WINDOWS = OS_NAME.contains("windows")
ext.IS_LINUX = OS_NAME.contains("linux")
ext.OS_ARCH = System.getProperty("os.arch")
ext.IS_64 = OS_ARCH.toLowerCase().contains("64")
ext.HAS_JAVAFX_MODULES = false
def inStream2 = new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.ProcessBuilder(JAVA, "--list-modules").start().getInputStream()));
try {
    String v;
    while ((v = inStream2.readLine()) != null) {
        v = v.trim();
        if (v.startsWith("javafx.base")) ext.HAS_JAVAFX_MODULES = true;
    }
} finally {
    inStream2.close();
}
System.out.println("HAS_JAVAFX_MODULES: ${HAS_JAVAFX_MODULES}")

// Define the number of threads to use when compiling (specifically for native compilation)
// On Mac we limit it to 1 by default due to problems running gcc in parallel
if (IS_MAC) {
    defineProperty("NUM_COMPILE_THREADS", "1")
} else {
    defineProperty("NUM_COMPILE_THREADS", "${Runtime.runtime.availableProcessors()}")
}

project.ext.defaultModuleSourcePath = rootProject.projectDir.path + '/modules/*/src/main/java'
project.ext.defaultModuleSourcePathShim = rootProject.projectDir.path + '/modules/*/src/{main,shims}/java'
ext.EXTRAADDEXPORTS = 'buildSrc/addExports'

repositories {
    mavenCentral()
}

test {
    executable = JAVA
    enableAssertions = true
    scanForTestClasses = false
    include("**/*Test.*")
    testLogging {
        // set options for log level LIFECYCLE
        events TestLogEvent.PASSED, TestLogEvent.SKIPPED,
                TestLogEvent.FAILED, TestLogEvent.STANDARD_OUT
        showExceptions true
        exceptionFormat TestExceptionFormat.FULL
        showCauses true
        showStackTraces true

        // set options for log level DEBUG and INFO
        debug {
            events TestLogEvent.STARTED, TestLogEvent.PASSED,
                    TestLogEvent.SKIPPED, TestLogEvent.FAILED,
                    TestLogEvent.STANDARD_OUT, TestLogEvent.STANDARD_ERROR
        }
        info.events = debug.events
        afterTest { desc, result ->
            if (desc.parent) {
                if (result.getResultType() == TestResult.ResultType.FAILURE) {
                    failedTestSummary += "${desc.getClassName()}#${desc.getName()} FAILED:\n" +
                            "${result.getExceptions()}\n"
                }
            }
        }
        afterSuite { desc, result ->
            if (!desc.parent) { // will match the outermost suite
                def output = "Results: ${result.resultType} (${result.testCount} tests, " +
                        "${result.successfulTestCount} successes, " +
                        "${result.failedTestCount} failures, " +
                        "${result.skippedTestCount} skipped)"
                def startItem = '|  ', endItem = '  |'
                def repeat = startItem + output + endItem
                println('\n' + ('-' * repeat.length()) + '\n' + repeat + '\n' + ('-' * repeat.length()))
                if (result.failedTestCount > 0) {
                    println(failedTestSummary)
                }
            }
        }
    }
    compileTestJava {
    }
}

// Return a list containing the --upgrade-module-path or --module-path
// used with Javac
List<String> computeModulePathArgs(String  pname, List<String> deps, boolean test) {
    List<String> mpa = HAS_JAVAFX_MODULES ? [ '--upgrade-module-path' ] : [ '--module-path' ]
    String mp = null
    deps.each { String projname ->
        def proj = project(projname)
        // for a non test set of args, we don't want the current module in the list
        // for a test test, we do need it to update what we built

        if (proj.hasProperty("moduleName") &&
                proj.buildModule &&
                !(!test && proj.name.equals(pname))) {

            File dir;
            if (test && proj.sourceSets.hasProperty('shims')) {
                dir = new File(proj.sourceSets.shims.java.outputDir, proj.ext.moduleName);
            } else {
                dir = new File(proj.sourceSets.main.java.outputDir, proj.ext.moduleName);
            }
            if (mp == null) {
                mp = dir.path
            } else {
                mp = mp + File.pathSeparator + dir.path
            }
        }
    }

    // in some cases like base we could end up with an empty
    // path... make sure we don't pass one back
    if (mp == null) {
        return null
    }

    mpa += mp

    if (!HAS_JAVAFX_MODULES) {
        String addm = null
        deps.each {String projname ->
            def proj = project(projname)
            // for a non test set of args, we don't want the current module in the list
            // for a test test, we do need it to update what we built

            if (proj.hasProperty("moduleName") &&
                    proj.buildModule &&
                    !(!test && proj.name.equals(pname))) {

                if (addm == null) {
                    addm = proj.moduleName
                } else {
                    addm = addm + "," + proj.moduleName
                }
            }
        }
        if (addm != null) {
            mpa += "--add-modules=${addm}"
        }
    }

    return mpa
}

/**
 * Manages the execution of some closure which is responsible for producing
 * content for a properties file built at build time and stored in the
 * root project's $buildDir, and then loading that properties file and
 * passing it to the processor closure.
 *
 * This is used on windows to produce a properties file containing all the
 * windows visual studio paths and environment variables, and on Linux
 * for storing the results of pkg-config calls.
 *
 * @param name the name of the file to produce
 * @param loader a closure which is invoked, given the properties file. This
 *        closure is invoked only if the properties file needs to be created
 *        and is responsible for populating the properties file.
 * @param processor a closure which is invoked every time this method is
 *        called and which will be given a Properties object, fully populated.
 *        The processor is then responsible for doing whatever it is that it
 *        must do with those properties (such as setting up environment
 *        variables used in subsequent native builds, or whatnot).
 */
void setupTools(String name, Closure loader, Closure processor) {
    // Check to see whether $buildDir/$name.properties file exists. If not,
    // then generate it. Once generated, we need to read the properties file to
    // help us define the defaults for this block of properties
    File propFile = file("$buildDir/${name}.properties");
    if (!propFile.exists()) {
        // Create the properties file
        propFile.getParentFile().mkdirs();
        propFile.createNewFile();
        loader(propFile);
    }

    // Try reading the properties in order to define the properties. If the property file cannot
    // be located, then we will throw an exception because we cannot guess these values
    InputStream propStream = null;
    try {
        Properties properties = new Properties();
        propStream = new FileInputStream(propFile);
        properties.load(propStream);
        processor(properties);
    } finally {
        try { propStream.close() } catch (Exception e) { }
    }
}

/**
 * If the given named property is not defined, then this method will define
 * it with the given defaultValue. Any properties defined by this method can
 * be substituted on the command line by using -P, or by specifying a
 * gradle.properties file in the user home dir
 *
 * @param name The name of the property to define
 * @param defaultValue The default value to assign the property
 */
void defineProperty(String name, String defaultValue) {
    if (!project.hasProperty(name)) {
        project.ext.set(name, defaultValue);
    }
}

/**
 * If the given named property is not defined, then this method will attempt to
 * look up the property in the props map, and use the defaultValue if it cannot be found.
 *
 * @param name The name of the property to look up and/or define
 * @param props The properties to look for the named property in, if it has not already been defined
 * @param defaultValue The default value if the property has not been defined and the
 *                     props map does not contain the named property
 */
void defineProperty(String name, Properties props, String defaultValue) {
    if (!project.hasProperty(name)) {
        project.ext.set(name, props.getProperty(name, defaultValue));
    }
}

// perform common project manipulation for modules
void commonModuleSetup(Project p, List<String> moduleChain) {

    p.ext.moduleChain = moduleChain

    if (p.hasProperty("moduleName")) {
        p.ext.moduleDir = new File (p.sourceSets.main.java.outputDir, "${p.moduleName}")
        if (p.sourceSets.hasProperty('shims')) {
            p.ext.moduleShimsDir = new File (p.sourceSets.shims.java.outputDir, "${p.moduleName}")
        }
    }

    def mpa = computeModulePathArgs(p.name, moduleChain, false)
    if (mpa != null) {
        p.ext.modulePathArgs = mpa
    }

    p.ext.testModulePathArgs = computePatchModuleArgs(moduleChain, true, false)
    p.ext.patchModuleArgs = computePatchModuleArgs(moduleChain ,false, true)
    p.ext.testPatchModuleArgs = computePatchModuleArgs(moduleChain, true, true)

    moduleChain.each() {e ->
        if (!e.equals(p.name)) {
            p.compileJava.dependsOn(project(e).classes)
            p.compileTestJava.dependsOn(project(e).testClasses)
        }
    }

    // read in any addExports file
    File addExportsFile = new File(p.projectDir,"src/test/addExports")
    if (addExportsFile.exists()) {
        List<String> ae = []
        addExportsFile.eachLine { line ->
            line = line.trim()
            if (!(line.startsWith("#") || line.equals(""))) {
                ae += line.split(' ')
            }
        }
        p.ext.testAddExports  = ae.flatten()
    }

    // read in the temporary addExports file EXTRAADDEXPORTS)
    //
    // These extra --add-exports will be used in two places and so we
    // create/modify two items:
    // p.testAddExports - add the extra items so they are included in test builds
    //
    // p.extraAddExports - for use in any other place where we don't automatically update
    //    for example any non modular, non 'test' compile, any compile that does not
    //    use a module-source-path that includes the dependent modules
    //
    // Note that we don't modify the modular build (main, shims) because they use
    // module-info directly, and we don't want to cover up any missing items there.
    //
    if (!rootProject.hasProperty("EXTRA_ADDEXPORTS_ARGS")) {
        List<String> extraAddExportsList = []
        String fullae = ""
        File tmpaddExportsFile = new File(rootProject.projectDir, EXTRAADDEXPORTS)
        if (tmpaddExportsFile.exists()) {
            String nl = System.getProperty("line.separator")
            tmpaddExportsFile.eachLine { line ->
                line = line.trim()
                fullae += line + nl
                if (!(line.startsWith("#") || line.equals(""))) {
                    extraAddExportsList += line.split(' ')
                }
            }
        }
        // This string is used in the creation of the build/*.args files
        // so we preserve comments
        if (!extraAddExportsList.isEmpty()) {
            rootProject.ext.EXTRA_ADDEXPORTS_STRING = fullae
        }
        rootProject.ext.EXTRA_ADDEXPORTS_ARGS = extraAddExportsList
    }

    if (HAS_JAVAFX_MODULES) {
        // use this variable, because it shows we have a non empty addition
        if (rootProject.hasProperty("EXTRA_ADDEXPORTS_STRING")) {
            p.ext.extraAddExports = EXTRA_ADDEXPORTS_ARGS.flatten()
            if (p.hasProperty("testAddExports")) {
                p.testAddExports += EXTRA_ADDEXPORTS_ARGS.flatten()
            }
        }
    }
}
// Return list with the arguments needed for --patch-module or --module-path
// for the provided projects. Used with Java executables ie. tests
List<String> computePatchModuleArgs(List<String> deps, boolean test, boolean includeJLP) {
    List<String> pma = []

    if (HAS_JAVAFX_MODULES) {
        deps.each { String projname ->
            def proj = project(projname)
            if (proj.hasProperty("moduleName")) {
                File dir;
                if (test && proj.sourceSets.hasProperty('shims')) {
                    dir = file("${rootProject.buildDir}/shims")
                } else {
                    dir = file("${rootProject.buildDir}/modular-sdk/modules")
                }
                String moduleName = proj.ext.moduleName
                String dirpath = "${dir}/${moduleName}"
                pma += "--patch-module=${moduleName}=${dirpath}"
            }
        }
    } else {
        String mp = null
        deps.each { String projname ->
            def proj = project(projname)
            if (proj.hasProperty("moduleName")) {
                String moduleName = proj.ext.moduleName
                File dir;
                if (test && proj.sourceSets.hasProperty('shims')) {
                    dir = file("${rootProject.buildDir}/shims/${moduleName}")
                } else {
                    dir = file("${rootProject.buildDir}/sdk/lib/${moduleName}.jar")
                }
                if (mp == null) {
                    mp = dir.path
                } else {
                    mp = mp + File.pathSeparator + dir.path
                }
            }
        }

        // in some cases like base we could end up with an empty
        // path... make sure we don't pass one back
        if (mp == null) {
            return null
        }

        pma += '--module-path'
        pma += mp

        String addm = null
        deps.each {String projname ->
            def proj = project(projname)
            if (proj.hasProperty("moduleName") && proj.buildModule) {
                if (addm == null) {
                    addm = proj.moduleName
                } else {
                    addm = addm + "," + proj.moduleName
                }
            }
        }
        if (addm != null) {
            pma += "--add-modules=${addm}"
        }
    }

    return pma
}

subprojects {
    apply plugin: "java"
}

project(":fxpackagerservices") {
    project.ext.buildModule = true
    project.ext.includeSources = true
    project.ext.moduleRuntime = false
    project.ext.moduleName = "jdk.packager.services"

    sourceSets {
        main
        test
    }

    project.ext.moduleSourcePath = defaultModuleSourcePath
    project.ext.moduleSourcePathShim = defaultModuleSourcePathShim

    // commonModuleSetup(project, [ 'base', 'graphics', 'controls' ])

    compileTestJava.enabled = false // FIXME: JIGSAW -- support this with modules

    test {
        enabled = false // FIXME: JIGSAW -- support this with modules
        logger.info("JIGSAW Testing disabled for fxpackagerservices")
    }
}

project(":fxpackager") {
    project.ext.buildModule = true
    project.ext.includeSources = true
    project.ext.moduleName = "jdk.packager"
    project.ext.moduleRuntime = false
    project.ext.moduleSourcePath = defaultModuleSourcePath
    project.ext.moduleSourcePathShim = defaultModuleSourcePathShim

    sourceSets {
        main
        test
    }

    commonModuleSetup(project, [ 'fxpackagerservices', 'fxpackager' ])

    manifest {
        attributes(
                "Main-Class": "com.sun.openjfx.tools.packager.Main"
        )
    }

    repositories {
        mavenCentral()
    }

    dependencies {
        testCompile group: "junit", name: "junit", version: "4.8.2"
        testCompile project(":fxpackager")
    }

    //Note: these should be reflected in the module-info additions passed to the JDK
    compileJava.options.compilerArgs.addAll([
            "--add-exports=java.base/sun.security.timestamp=jdk.packager",
            "--add-exports=java.base/sun.security.x509=jdk.packager",

            // Note: retain jdk.jlink qualified export for cases where the JDK does
            // not contain the jdk.packager module.
            "--add-exports=jdk.jlink/jdk.tools.jlink.internal.packager=jdk.packager",

            // Note: not in extras...
            "--add-exports=java.base/sun.security.pkcs=jdk.packager",
            "--add-exports=java.logging/java.util.logging=jdk.packager",
    ])

    /*
    task buildVersionFile() {
        File dir = new File("${project.projectDir}/build/resources/antplugin/resources");
        File versionFile = new File(dir, "/version.properties");
        doLast {
            dir.mkdirs()
            if (!versionFile.exists()) {
                versionFile << "version=0.0.1\n"
            }
        }
        outputs.file(versionFile)
    }
    */

    // The "man" task will create a $buildDir/man containing the man
    // files for the system being built
    task man(type: Copy) {
        includeEmptyDirs = false
        enabled = IS_LINUX || IS_MAC
        from "src/main/man"
        into "$buildDir/man"
        exclude "**/*.html"
        if (IS_MAC) exclude "**/ja_JP.UTF-8/**"
    }
    processResources.dependsOn man


    String buildClassesDir = "${sourceSets.main.output.classesDir}/${moduleName}"

    if (IS_WINDOWS) {
        setupTools("windows_tools",
            { propFile ->
                // Create the properties file
                ByteArrayOutputStream results = new ByteArrayOutputStream();
                String winsdkDir = System.getenv().get("WINSDK_DIR");
                exec({
                    environment([
                            "WINSDKPATH" : winsdkDir == null ? "" : winsdkDir,
                            "CONF"       : "/$CONF", // TODO does this mean the generated properties must be reset when in a different configuration?
                            "VCARCH"     : IS_64 ? "amd64" : "x86",
                            "SDKARCH"    : IS_64 ? "/x64" : "/x86",
                    ]);
                    commandLine("cmd", "/q", "/c", "genVSproperties.bat");
                    setStandardOutput(results);
                });
                BufferedReader reader = new BufferedReader(new StringReader(results.toString().trim()));
                reader.readLine();
                reader.readLine();
                String line;
                while ((line = reader.readLine()) != null && !line.startsWith("######")) {
                    line = line.replace("\\", "/").replace("/@@ENDOFLINE@@", "").replace("@@ENDOFLINE@@", "").replace("//", "/").replace("windows.vs.", "WINDOWS_VS_");
                    propFile << line << "\r\n";
                }
            },
            { properties ->
                defineProperty("WINDOWS_VS_VSINSTALLDIR", properties, "c:/Program Files (x86)/Microsoft Visual Studio/2017/Professional");
                defineProperty("WINDOWS_VS_WINSDKDLLINSTALLDIR", properties, "c:/Program Files (x86)/Windows Kits/10/Redist/ucrt/DLLs");
                defineProperty("WINDOWS_SDK_DIR", properties, System.getenv().get("WINSDK_DIR"))
                defineProperty("WINDOWS_SDK_VERSION", properties, "")
                defineProperty("WINDOWS_VS_VCINSTALLDIR", properties, "$WINDOWS_VS_VSINSTALLDIR/VC")
                defineProperty("WINDOWS_VS_DEVENVDIR", properties, "$WINDOWS_VS_VSINSTALLDIR/Common7/IDE")
                defineProperty("WINDOWS_VS_DEVENVCMD", properties, "$WINDOWS_VS_DEVENVDIR/VCExpress.exe")
                defineProperty("WINDOWS_VS_MSVCDIR", properties, WINDOWS_VS_VCINSTALLDIR)
                defineProperty("WINDOWS_DXSDK_DIR", properties, System.getenv().get("DXSDK_DIR"))
                defineProperty("WINDOWS_VS_INCLUDE", properties, "$WINDOWS_VS_VCINSTALLDIR/INCLUDE;" + "$WINDOWS_SDK_DIR/include;")
                defineProperty("WINDOWS_VS_VER", properties, "150")
                defineProperty("WINDOWS_VS_LIB", properties, "$WINDOWS_VS_VCINSTALLDIR/LIB;" + "$WINDOWS_SDK_DIR/lib;")
                defineProperty("WINDOWS_VS_LIBPATH", properties, "$WINDOWS_VS_VCINSTALLDIR/LIB;")
                defineProperty("WINDOWS_VS_PATH", properties, "$WINDOWS_VS_DEVENVDIR;" +
                        "$WINDOWS_VS_VSINSTALLDIR/VC/BIN;" +
                        "$WINDOWS_VS_VSINSTALLDIR/Common7/Tools;" +
                        "$WINDOWS_VS_VCINSTALLDIR/VCPackages;" +
                        "$WINDOWS_SDK_DIR/bin/NETFX 4.0 Tools;" +
                        "$WINDOWS_SDK_DIR/bin;" +
                        System.getenv().get("PATH"))
            }
        )

        def winVsVer = Integer.parseInt(WINDOWS_VS_VER)
        if (WINDOWS_SDK_DIR == null || WINDOWS_SDK_DIR == "") {
            throw new GradleException("FAIL: WINSDK_DIR not defined");
        }

        def msvcVer = System.getenv("MSVC_VER") ?: "14.10.25017"
        def msvcBinDir = ""
        if (winVsVer == 150) {
            msvcBinDir = (IS_64
                    ? "$WINDOWS_VS_VSINSTALLDIR/VC/Tools/MSVC/$msvcVer/bin/HostX64/x64"
                    : "$WINDOWS_VS_VSINSTALLDIR/VC/Tools/MSVC/$msvcVer/bin/HostX86/x86")
        } else if (winVsVer <= 120) {
            msvcBinDir = (IS_64
                    ? "$WINDOWS_VS_VSINSTALLDIR/VC/BIN/amd64"
                    : "$WINDOWS_VS_VSINSTALLDIR/VC/BIN")
        }

        // Define set of flags shared for all targets that support debug compilation
        def ccDebugFlags = IS_DEBUG_NATIVE ? ["/MDd", "/Od", "/Zi", "/DDEBUG"] : ["/O2", "/MD", "/DNDEBUG"]

        ext.WINDOWS_NATIVE_COMPILE_ENVIRONMENT = [
                "VCINSTALLDIR"         : WINDOWS_VS_VCINSTALLDIR,
                "VSINSTALLDIR"         : WINDOWS_VS_VSINSTALLDIR,
                "DEVENVDIR"            : WINDOWS_VS_DEVENVDIR,
                "MSVCDIR"              : WINDOWS_VS_MSVCDIR,
                "VS_VER"               : WINDOWS_VS_VER,
                "PATH"                 : WINDOWS_VS_PATH,
                "INCLUDE"              : WINDOWS_VS_INCLUDE,
                "LIB"                  : WINDOWS_VS_LIB,
                "LIBPATH"              : WINDOWS_VS_LIBPATH,
                "DXSDK_DIR"            : WINDOWS_DXSDK_DIR
        ];

        def winSdkBinDir = "$WINDOWS_SDK_DIR/Bin"
        if (WINDOWS_VS_VER != "100") {
            winSdkBinDir += "/" + (IS_64 ? "x64" : "x86")
        }

        if (!file("$winSdkBinDir/RC.Exe").exists()) {
            winSdkBinDir = "$WINDOWS_SDK_DIR/Bin/$WINDOWS_SDK_VERSION"
            if (WINDOWS_VS_VER != "100") {
                winSdkBinDir += "/" + (IS_64 ? "x64" : "x86")
            }
        }
        println "winSdkBinDir=$winSdkBinDir"
        ext.RC = "${winSdkBinDir}/rc.exe"
        ext.MC = "${winSdkBinDir}/mt.exe"
        def rcCompiler = RC
        if (!file(RC).exists()) throw new GradleException("FAIL: cannot find RC: " + RC)

        def msvcRedistVer = System.getenv("MSVC_REDIST_VER") ?: "14.10.25008"
        String msvcRedstDir = (IS_64
                ? "$WINDOWS_VS_VSINSTALLDIR/VC/Redist/MSVC/$msvcRedistVer/x64"
                : "$WINDOWS_VS_VSINSTALLDIR/VC/Redist/MSVC/$msvcRedistVer/x86")
        def WINDOWS_DLL_VER = WINDOWS_VS_VER
        ext.MSVCR = null
        ext.MSVCP = null

        def windowsCRTVer = System.getenv("WINDOWS_CRT_VER") ?: "150"
        if (WINDOWS_VS_VER == "150") {
            WINDOWS_DLL_VER = "140"
            ext.MSVCR = "${msvcRedstDir}/Microsoft.VC${windowsCRTVer}.CRT/vcruntime${WINDOWS_DLL_VER}.dll"
            ext.MSVCP = "${msvcRedstDir}/Microsoft.VC${windowsCRTVer}.CRT/msvcp${WINDOWS_DLL_VER}.dll"
        }
        // Product version variables passed to RC:
        def rcVer = "0.0.1"
        def rcVerMajor = 0
        def rcVerMinor = 0
        def rcVerSecurity = 0
        def rcVerPatch = 1
        def rcVerFile = "${rcVerMajor},${rcVerMinor},${rcVerSecurity},${rcVerPatch}"
        def rcVerBuild = "0.0.1"
        def rcVerCopyrYear = "${Calendar.getInstance().get(Calendar.YEAR)}"
        def rcFlags = [
                "/d", "\"JFX_COMPANY=${COMPANY_NAME}\"",
                "/d", "\"JFX_COMPONENT=${PRODUCT_NAME} ${PLATFORM_NAME} binary\"",
                "/d", "\"JFX_NAME=${PRODUCT_NAME} ${PLATFORM_NAME} ${rcVerMajor}\"",
                "/d", "\"JFX_VER=${rcVer}\"",
                "/d", "\"JFX_BUILD_ID=${rcVerBuild}\"",
                "/d", "\"JFX_COPYRIGHT=Copyright \u00A9 ${rcVerCopyrYear}\"",
                "/d", "\"JFX_FVER=${rcVerFile}\"",
                "/d", "\"JFX_FTYPE=0x2L\"",
                "/nologo"
        ];

        ext.WIN = [:]
        WIN.launcher = [:]
        WIN.launcher.ccFlags = ["/nologo", "/W3", "/MT", "/EHsc", "/D_WINDOWS", "/DUNICODE", "/D_UNICODE", "/DWIN32",
                                "/D_LITTLE_ENDIAN", "/DWIN32_LEAN_AND_MEAN", "/I$JDK_HOME/include", "/I$JDK_HOME/include/win32",
                                ccDebugFlags].flatten();
        WIN.launcher.linkFlags = ["/link", "/nologo", "/WX", "/SUBSYSTEM:WINDOWS", "user32.lib", "shell32.lib", "advapi32.lib"]
        if (IS_DEBUG_NATIVE) WIN.launcher.linkFlags.add("/debug");

        WIN.launcherlibrary = [:]
        WIN.launcherlibrary.ccFlags = ["/nologo", "/W3", "/FS",
                                       // "/WX",
                                       "/EHsc", "/c", "/D_WINDOWS", "/DUNICODE", "/D_UNICODE", "/DWIN32",
                                       "/D_LITTLE_ENDIAN", "/DWIN32_LEAN_AND_MEAN", "/I$JDK_HOME/include", "/I$JDK_HOME/include/win32",
                                       ccDebugFlags].flatten();
        WIN.launcherlibrary.linkFlags = ["/nologo", "/WX", "/DLL", "/SUBSYSTEM:WINDOWS", "user32.lib", "shell32.lib", "advapi32.lib", "ole32.lib"]
        if (IS_DEBUG_NATIVE) WIN.launcherlibrary.linkFlags.add("/debug");

        WIN.fxpackager = [:]
        WIN.fxpackager.nativeSource = [file("src/main/native/javapackager/win")] // remove modules/jdk.packager from file?
        WIN.fxpackager.ccFlags = ["/nologo", "/W3", "/EHsc", "/MT", "/GS",  "/DUNICODE", "/D_UNICODE",
                            "/DWIN32", "/D_LITTLE_ENDIAN", "/DWIN32_LEAN_AND_MEAN",
                            "/D_WIN32_WINDOWS=0X0500", "/D_WIN32_WINNT=0X0500",
                            "/I$JDK_HOME/include", "/I$JDK_HOME/include/win32",
                            "/O2", "-c"]
        WIN.fxpackager.linkFlags = ["/nologo", "/SUBSYSTEM:CONSOLE", "/opt:REF", "/incremental:no", "/manifest", "kernel32.lib", "advapi32.lib"];
        WIN.fxpackager.rcSource = file("src/main/native/javapackager/win/javapackager.rc")
        WIN.fxpackager.rcCompiler = rcCompiler
        WIN.fxpackager.rcFlags = [
            "/l", "0x409",
            "/d", "JFX_FNAME=javapackager.exe",
            "/d", "JFX_INTERNAL_NAME=javapackager",
        rcFlags].flatten();

        task buildWinLauncher(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher";
            matches = "WinLauncher\\.cpp";
            params.addAll(WIN.launcher.ccFlags);
            output(file("$buildDir/native/WinLauncher"));
            source(file("src/main/native/launcher/win"));
            compiler = "${msvcBinDir}/cl.exe"
            exe = true;
            linkerOptions.addAll(WIN.launcher.linkFlags);
        }

        task copyWinLauncher(type: Copy, group: "Build", dependsOn: buildWinLauncher) {
            from "$buildDir/native/WinLauncher/WinLauncher.exe"
            from "$MSVCR"
            from "$MSVCP"
            into "${buildClassesDir}/com/oracle/tools/packager/windows"
        }

        task compileWinLibrary(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher library";
            matches = ".*\\.cpp"
            source(file("src/main/native/library/common"));
            params.addAll(WIN.launcherlibrary.ccFlags)
            output(file("$buildDir/native/WinLauncher/obj"));
            compiler = "${msvcBinDir}/cl.exe"
        }

        task linkWinLibrary(type: LinkTask, group: "Build", dependsOn: compileWinLibrary) {
            description = "Links native sources for the application co-bundle launcher library";
            objectDir = file("$buildDir/native/WinLauncher/obj")
            linkParams.addAll(WIN.launcherlibrary.linkFlags);
            lib = file("$buildDir/native/WinLauncher/packager.dll")
            linker = "${msvcBinDir}/link.exe"
        }

        task copyWinLibrary(type: Copy, group: "Build", dependsOn: linkWinLibrary) {
            from "$buildDir/native/WinLauncher/packager.dll"
            into "${buildClassesDir}/com/oracle/tools/packager/windows"
        }

        task buildWinLauncherSvc(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher";
            matches = "WinLauncherSvc\\.cpp";
            params.addAll(WIN.launcher.ccFlags);
            output(file("$buildDir/native/WinLauncherSvc"));
            source(file("src/main/native/service/win"));
            compiler = "${msvcBinDir}/cl.exe"
            exe = true;
            linkerOptions.addAll(WIN.launcher.linkFlags);
        }

        task copyWinLauncherSvc(type: Copy, group: "Build", dependsOn: buildWinLauncherSvc) {
            from "$buildDir/native/WinLauncherSvc/WinLauncherSvc.exe"
            into "${buildClassesDir}/com/oracle/tools/packager/windows"
        }

        task compileLauncher(dependsOn: [copyWinLauncher, copyWinLibrary, copyWinLauncherSvc])

        task setupCompileJavaPackager(type: Copy, group: "Build") {
            mkdir "$buildDir/native"
            mkdir "$buildDir/native/javapackager"
            from file("src/main/native/javapackager/win/javapackager.manifest")
            into file("$buildDir/native/javapackager")
            filter { line->
                line = line.replace("FXVERSION", "0.0.0.1")
            }
        }

        task compileJavaPackager(type: CCTask, group: "Build", dependsOn: setupCompileJavaPackager) {
            description = "Compiles native sources for javapackager.exe"
            matches = ".*\\.cpp"
            params.addAll(WIN.fxpackager.ccFlags)
            compiler = "${msvcBinDir}/cl.exe"
            output(file("$buildDir/native/javapackager/obj"))
            source WIN.fxpackager.nativeSource
            doLast {
                mkdir "$buildDir/native"
                exec {
                    environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
                    commandLine(WIN.fxpackager.rcCompiler)
                    args(WIN.fxpackager.rcFlags)
                    args("/fo$buildDir/native/javapackager/javapackager.res")
                    args(WIN.fxpackager.rcSource)
                }
            }
        }

        task linkJavaPackager(type: LinkTask, dependsOn: compileJavaPackager, group: "Build") {
            description = "Links javapackager.exe"
            objectDir = file("$buildDir/native/javapackager/obj")
            linkParams.addAll(WIN.fxpackager.linkFlags);
            lib = file("$buildDir/native/javapackager/javapackager.exe")
            linker = "${msvcBinDir}/link.exe"
            doLast {
                exec({
                    commandLine("$MC", "-manifest",
                            "$buildDir/native/javapackager/javapackager.manifest",
                            "-outputresource:$buildDir/native/javapackager/javapackager.exe")
                    environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
                })
            }
        }

        task copyJavaPackager(type: Copy, group: "Build", dependsOn: linkJavaPackager) {
            from file("$buildDir/native/javapackager/javapackager.exe")
            into file("$buildDir/javapackager")
        }

        task buildJavaPackager(dependsOn: [copyJavaPackager])
    } else if (IS_LINUX) {

        ext.LINUX = [:]
        LINUX.launcher = [:]
        LINUX.launcher.ccFlags = ["-Wextra", "-Wformat", "-Wformat-security", "-DJAVAARCH=\"$OS_ARCH\"", "-I$JDK_HOME/include", "-I$JDK_HOME/include/linux", "-c"]
        LINUX.launcher.linkFlags = ["-ldl"]
        if (!IS_64) {
            LINUX.launcher.ccFlags += "-m32"
            LINUX.launcher.linkFlags += "-m32"
        }
        LINUX.launcherlibrary = [:]
        LINUX.launcherlibrary.ccFlags = ["-Wextra", "-Wformat", "-Wformat-security", "-DJAVAARCH=\"$OS_ARCH\"", "-I$JDK_HOME/include", "-I$JDK_HOME/include/linux", "-c", "-fPIC"]
        LINUX.launcherlibrary.linkFlags = ["-ldl", "-lpthread", "-shared"]
        if (!IS_64) {
            LINUX.launcherlibrary.ccFlags += "-m32"
            LINUX.launcherlibrary.linkFlags += "-m32"
        }

        task compileLinuxLauncher(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher"
            matches = ".*\\.cpp"
            source file("src/main/native/launcher/linux")
            params.addAll(LINUX.launcher.ccFlags)
            compiler = "gcc"
            output(file("$buildDir/native/linuxlauncher/launcherobj"))
        }

        task linkLinuxLauncher(type: LinkTask, dependsOn: compileLinuxLauncher, group: "Build") {
            description = "Links native dynamic library for the application co-bundle launcher"
            objectDir = file("$buildDir/native/linuxlauncher/launcherobj")
            linkParams.addAll(LINUX.launcher.linkFlags)
            linker = "g++"
            lib = file("${buildClassesDir}/com/oracle/tools/packager/linux/JavaAppLauncher")
        }

        task compileLinuxLibrary(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher library"
            matches = ".*\\.cpp"
            source file("src/main/native/library/common")
            params.addAll(LINUX.launcherlibrary.ccFlags)
            compiler = "gcc"
            output(file("$buildDir/native/linuxlauncher/obj"))
        }

        task linkLinuxLibrary(type: LinkTask, dependsOn: compileLinuxLibrary, group: "Build") {
            description = "Links native dynamic library for the application co-bundle launcher library"
            objectDir = file("$buildDir/native/linuxlauncher/obj")
            linkParams.addAll(LINUX.launcherlibrary.linkFlags)
            linker = "g++"
            lib = file("${buildClassesDir}/com/oracle/tools/packager/linux/libpackager.so")
        }

        task compileLauncher(dependsOn: [linkLinuxLauncher, linkLinuxLibrary])
    } else if (IS_MAC) {
        /*
         * Define settings for Mac compilation. If we don't find the preferred SDK
         * in the default location then we will use "xcodebuild" to locate a suitable SDK.
         * In extreme cases you can provide your own properties in your home dir to
         * override these settings or pass them on the command line.
         */
        def prefSdkVersion = "10.9"
        def defaultSdkPath = "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX${prefSdkVersion}.sdk";

        // Set the minimum API version that we require (developers do not need to override this)
        // Note that this is not necessarily the same as the preferred SDK version
        defineProperty("MACOSX_MIN_VERSION", "10.9");

        // Create $buildDir/mac_tools.properties file and load props from it
        setupTools("mac_tools",
                { propFile ->
                    propFile << ""
                    if (!file(defaultSdkPath).isDirectory()) {
                        // Get list of all macosx sdks
                        ByteArrayOutputStream results = new ByteArrayOutputStream();
                        exec {
                            commandLine("xcodebuild", "-version", "-showsdks");
                            setStandardOutput(results);
                        }

                        BufferedReader reader = new BufferedReader(new StringReader(results.toString().trim()));
                        // If our preferred SDK is in the list use it, else use the default
                        String sdk = "macosx"
                        String prefSdk = sdk + prefSdkVersion
                        while (true) {
                            def line = reader.readLine();
                            if (line == null) break;
                            if (line.contains("-sdk ${prefSdk}")) {
                                sdk = prefSdk
                                break;
                            }
                        }

                        results = new ByteArrayOutputStream();
                        exec {
                            commandLine("xcodebuild", "-version", "-sdk", sdk, "Path");
                            setStandardOutput(results);
                        }
                        String sdkPath = results.toString().trim();
                        propFile << "MACOSX_SDK_PATH=" << sdkPath << "\n";
                    }
                },
                { properties ->
                    defineProperty("MACOSX_SDK_PATH", properties, defaultSdkPath)
                }
        )
        println "MACOSX_MIN_VERSION = $MACOSX_MIN_VERSION"
        println "MACOSX_SDK_PATH = $MACOSX_SDK_PATH"

        if (!file(MACOSX_SDK_PATH).isDirectory()) {
            throw new GradleException("FAIL: Cannot find $MACOSX_SDK_PATH")
        }

        // NOTE: There is no space between -iframework and the specified path
        def commonParams = [
                "-mmacosx-version-min=$MACOSX_MIN_VERSION",
                "-isysroot", "$MACOSX_SDK_PATH",
                "-iframework$MACOSX_SDK_PATH/System/Library/Frameworks",
                "-arch", "x86_64"]

        def ccBaseFlags = [
                commonParams,
                "-I$JDK_HOME/include",
                "-I$JDK_HOME/include/darwin"].flatten()
        ext.MAC = [:]
        MAC.launcher = [:]
        MAC.launcher.ccFlags = [
                "-std=c99",
                ccBaseFlags,
                "-framework", "Cocoa",
                IS_DEBUG_NATIVE ? ["-DDEBUG", "-O0"] : ["-O3", "-DNDEBUG"]].flatten()
        MAC.launcher.linkFlags = ["-ldl"]

        MAC.launcherlibrary = [:]
        MAC.launcherlibrary.ccFlags = [
                "-c",
                ccBaseFlags,
                IS_DEBUG_NATIVE ? ["-DDEBUG", "-O0"] : ["-O3", "-DNDEBUG"]].flatten()
        MAC.launcherlibrary.ccFlags += "-stdlib=libc++"
        MAC.launcherlibrary.linkFlags = ["-ldl", "-dynamiclib",
                                         "-framework", "Cocoa",
                                         "-stdlib=libc++"]

        task buildMacLauncher(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher"
            matches = ".*\\.m"
            source file("src/main/native/launcher/mac")
            params.addAll(MAC.launcher.ccFlags)
            compiler = "clang"
            output(file("${buildClassesDir}/com/oracle/tools/packager/mac"))
            outputs.file(file("${buildClassesDir}/main/com/oracle/tools/packager/mac/JavaAppLauncher"))
            eachOutputFile = { f ->
                return new File(f.getParent(), "JavaAppLauncher")
            }
        }

        task compileMacLibrary(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher library"
            matches = ".*\\.cpp|.*\\.mm"
            source file("src/main/native/library/common");
            params.addAll(MAC.launcherlibrary.ccFlags)
            compiler = "clang"
            output(file("$buildDir/native/maclauncher/obj"))
        }

        task linkMacLibrary(type: LinkTask, group: "Build", dependsOn: compileMacLibrary) {
            description = "Links native sources for the application co-bundle launcher library"
            objectDir = file("$buildDir/native/maclauncher/obj")
            linkParams.addAll(MAC.launcherlibrary.linkFlags)
            linker = "clang++"
            lib = file("${buildClassesDir}/com/oracle/tools/packager/mac/libpackager.dylib")
        }

        task compileLauncher(dependsOn: [buildMacLauncher, linkMacLibrary])
    }

    // Builds the javapackager executable. For everything other than windows,
    // this is simply moving the existing shell script and ensuring it has proper
    // permissions. For Windows, this includes compiling the native executable
    if (!IS_WINDOWS) {
        task buildJavaPackager(type: Copy, group: "Build") {
            enabled = true
            from "src/main/native/javapackager/shell"
            into "$buildDir/javapackager"
            fileMode = 0755
        }
    }

    assemble.dependsOn compileLauncher
    assemble.dependsOn buildJavaPackager

    task setupPackagerFakeJar(type: Copy) {
        from "$projectDir/src/main/resources/com/oracle/tools/packager/linux/javalogo_white_48.png"
        from "$projectDir/src/main/resources/com/oracle/tools/packager/mac/GenericAppHiDPI.icns"
        from "$projectDir/src/main/resources/com/oracle/tools/packager/windows/javalogo_white_48.ico"
        from "$projectDir/src/test/resources/hello/java-logo2.gif"
        from "$projectDir/src/test/resources/hello/small.ico"
        from "$projectDir/src/test/resources/hello/test.icns"
        from "$projectDir/src/test/resources/hello/LICENSE-RTF.rtf"
        into project.file("$projectDir/build/tmp/tests/appResources")
    }


    task packagerFakeJar(type: Jar, dependsOn: [setupPackagerFakeJar]) {
        dependsOn compileTestJava
        from compileTestJava.destinationDir
        include "hello/**"

        destinationDir project.file("build/tmp/tests/appResources")
        archiveName "mainApp.jar"

        manifest {
            attributes(
                    "Main-Class": "hello.HelloRectangle",
                    "Custom-Attribute": " Is it stripped?"
            )
        }
    }

    task packagerFXPackagedJar(type: Jar) {
        dependsOn packagerFakeJar
        from compileTestJava.destinationDir
        include "hello/**"

        destinationDir project.file("build/tmp/tests/appResources")
        archiveName "packagedMainApp.jar"

        manifest {
            attributes(
                    "JavaFX-Application-Class": "hello.TestPackager",
            )
        }
    }

    compileTestJava.enabled = false // FIXME: JIGSAW -- support this with modules
    test {
        enabled = false // FIXME: JIGSAW -- support this with modules
        logger.info("JIGSAW Testing disabled for fxpackager")

        dependsOn packagerFXPackagedJar
        systemProperty "RETAIN_PACKAGER_TESTS", RETAIN_PACKAGER_TESTS
        systemProperty "TEST_PACKAGER_DMG", TEST_PACKAGER_DMG
        systemProperty "FULL_TEST", FULL_TEST
        executable = JAVA;
    }

    def packagerDevOpts = []
    try {
        packagerDevOpts.addAll(PACKAGER_DEV_OPTS.split(' '))
    } catch (MissingPropertyException ignore) {
        packagerDevOpts.addAll("image")
    }

    task packagerDev(dependsOn: [jar, testClasses, packagerFakeJar], type:JavaExec) {
        workingDir = project.file("build/tmp/tests/appResources/")
        executable = JAVA
        classpath = project.files("build/classes/test", "build/resources/test")
        main = "hello.SimpleBundle"
        args = [
                '--module-path', JDK_JMODS,
                '-o', "$projectDir/build/dev",
                '-all',
                packagerDevOpts
        ].flatten()
    }

    task createPackagerServicesModule(type: Jar) {
        if (project.hasProperty("DEBUGJDK_HOME")) {
            def dir = file("$DEBUGJDK_HOME/newmodules")
            dir.mkdirs()

            includeEmptyDirs = false
            archiveName = "jdk.packager.services.jar"
            destinationDir = dir

            from (project.file("$rootProject.buildDir/modular-sdk/modules/jdk.packager.services")) {
                include "**"
            }

            from (project.file("$rootProject.buildDir/../modules/jdk.packager/build/classes/java/main/jdk.packager.services")) {
                include "module-info.class"
            }
        }
    }

    task createPackagerModule(type: Jar) {
        if (project.hasProperty("DEBUGJDK_HOME")) {
            def dir = file("$DEBUGJDK_HOME/newmodules")
            dir.mkdirs()

            includeEmptyDirs = false
            archiveName = "jdk.packager.jar"
            destinationDir = dir

            from (project.file("$rootProject.buildDir/modular-sdk/modules/jdk.packager")) {
                include "**"
            }

            from (project.file("$rootProject.buildDir/../modules/jdk.packager/build/classes/java/main/jdk.packager")) {
                include "module-info.class"
            }
        }
    }

    task createRunScript() {
        def TEXT = "DEBUG_ARG=\"-J-Xdebug:\"\n" +
                "\n" +
                "# Argument parsing.\n" +
                "ARGS=()\n" +
                "for i in \"\$@\"; do\n" +
                "    if [[ \"\$i\" == \${DEBUG_ARG}* ]]; then\n" +
                "        ADDRESS=\${i:\${#DEBUG_ARG}}\n" +
                "        DEBUG=\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=\${ADDRESS}\"\n" +
                "    else\n" +
                "        ARGS+=(\"\$i\")\n" +
                "    fi\n" +
                "done\n" +
                "\n" +
                "\${JAVA_HOME}/bin/java.original --upgrade-module-path \${JAVA_HOME}/newmodules \$(IFS=\$\' \'; echo \"\${ARGS[*]}\")\n"

        doLast {
            new File("$DEBUGJDK_HOME/bin").mkdirs()
            def runscript = new File("$DEBUGJDK_HOME/bin/java")//.withWriter('utf-8') //{
            runscript.write(TEXT)
        }

        doLast {
            exec {
                commandLine('chmod',  '+x', "$DEBUGJDK_HOME/bin/java")
            }
        }
    }

    task createBuildScript() {
        def TEXT = "DEBUG_ARG=\"-J-Xdebug:\"\n" +
                "\n" +
                "# Argument parsing.\n" +
                "ARGS=()\n" +
                "for i in \"\$@\"; do\n" +
                "    if [[ \"\$i\" == \${DEBUG_ARG}* ]]; then\n" +
                "        ADDRESS=\${i:\${#DEBUG_ARG}}\n" +
                "        DEBUG=\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=\${ADDRESS}\"\n" +
                "    else\n" +
                "        ARGS+=(\"\$i\")\n" +
                "    fi\n" +
                "done\n" +
                "\n" +
                "\${JAVA_HOME}/bin/javac.original --upgrade-module-path \${JAVA_HOME}/newmodules \$(IFS=\$\' \'; echo \"\${ARGS[*]}\")\n"

        doLast {
            new File("$DEBUGJDK_HOME/bin").mkdirs()
            def buildscript = new File("$DEBUGJDK_HOME/bin/javac")//.withWriter('utf-8') //{
            buildscript.write(TEXT)
        }

        doLast {
            exec {
                commandLine('chmod',  '+x', "$DEBUGJDK_HOME/bin/javac")
            }
        }
    }

    task createDebugJDK(dependsOn: [createPackagerModule, createPackagerServicesModule, createRunScript, createBuildScript]) {
        def EXE = IS_WINDOWS ? ".exe" : ""

        doLast {
            copy {
                from SOURCEJDK_HOME
                into DEBUGJDK_HOME
                exclude("*/javapackager$EXE")
                exclude("*/java$EXE")
                exclude("*/javac$EXE")
                exclude("*/jdk.packager.services.jmod")
            }

            copy {
                from "$SOURCEJDK_HOME/bin/java$EXE"
                into "$DEBUGJDK_HOME/bin"
                rename "java$EXE", "java.original$EXE"
            }

            copy {
                from "$SOURCEJDK_HOME/bin/javac$EXE"
                into "$DEBUGJDK_HOME/bin"
                rename "javac$EXE", "javac.original$EXE"
            }

            copy {
                from "$rootProject.buildDir/modular-sdk/modules_cmds/jdk.packager/javapackager$EXE"
                into "$DEBUGJDK_HOME/bin"
            }

            copy {
                from "$DEBUGJDK_HOME/newmodules/jdk.packager.services.jar"
                into "$DEBUGJDK_HOME/jmods"
            }
        }
    }

    task copyRedistributableFiles(type: Copy) {
        def projectDir = "tools/java/legacy"
        def sourceDir = "src/$projectDir"
        def buildDir = "build/$projectDir"
        def resourceDir = "${moduleDir}/jdk/packager/internal/resources/tools/legacy"

        from "$sourceDir/jre.list"
        into project.file("$resourceDir")
    }

    processResources.dependsOn copyRedistributableFiles

    task copyDTtoPackager(type: Copy) {
        def destDt = "${moduleDir}/com/sun/javafx/tools/resource"
        from (sourceSets.main.output.resourcesDir) {
            includes = [ "resources/web-files/**" ]
        }
        into new File("$destDt", "dtoolkit")
    }

    processResources.dependsOn copyDTtoPackager
}
