import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent

import static org.apache.tools.ant.taskdefs.condition.Os.*

apply plugin: 'java'
sourceCompatibility = 1.9

def envJavaHome = System.getenv("JDK_HOME")
if (envJavaHome == null || envJavaHome.equals("")) envJavaHome = System.getenv("JAVA_HOME")
def javaHome = envJavaHome == null || envJavaHome.equals("") ? System.getProperty("java.home") : envJavaHome
def javaHomeFile = file(javaHome)
defineProperty("JDK_HOME",
        javaHomeFile.name == "jre" ?
                javaHomeFile.getParent().toString() :
                javaHomeFile.name.startsWith("jre") ?
                        new File(javaHomeFile.getParent(), "jdk1.${javaHomeFile.name.substring(3)}.0").toString() :
                        javaHome) // we have to bail and set it to something and this is as good as any!
ext.JAVA_HOME = JDK_HOME
defineProperty("CONF", "Debug")
defineProperty("JAVA", "$JDK_HOME/bin/java")
defineProperty("RETAIN_PACKAGER_TESTS", "true")
defineProperty("TEST_PACKAGER_DMG", "true")
defineProperty("FULL_TEST", "true")
defineProperty("JDK_JMODS", System.getenv("JDK_JMODS") ?: System.getenv("JDK_HOME") + "/jmods")
defineProperty("IS_DEBUG_NATIVE", "false")
defineProperty("PRODUCT_NAME", "OpenJFX")
defineProperty("COMPANY_NAME", "N/A")
defineProperty("PLATFORM_NAME", "Platform")
ext.IS_MAC = OS_NAME.contains("mac") || OS_NAME.contains("darwin")
ext.IS_WINDOWS = OS_NAME.contains("windows")
ext.IS_LINUX = OS_NAME.contains("linux")
ext.OS_ARCH = System.getProperty("os.arch")
ext.IS_64 = OS_ARCH.toLowerCase().contains("64")
ext.PLATFORM = IS_MAC ? 'mac' : (IS_WINDOWS ? 'win' : 'linux')
ext.HAS_JAVAFX_MODULES = false
def inStream2 = new BufferedReader(new InputStreamReader(new ProcessBuilder(JAVA, "--list-modules").start().getInputStream()))
try {
    String v
    while ((v = inStream2.readLine()) != null) {
        v = v.trim()
        if (v.startsWith("javafx.base")) {
            ext.HAS_JAVAFX_MODULES = true
        }
    }
} finally {
    inStream2.close()
}

// Define the number of threads to use when compiling (specifically for native compilation)
// On Mac we limit it to 1 by default due to problems running gcc in parallel
if (IS_MAC) {
    defineProperty("NUM_COMPILE_THREADS", "1")
} else {
    defineProperty("NUM_COMPILE_THREADS", "${Runtime.runtime.availableProcessors()}")
}

project.ext.defaultModuleSourcePath = rootProject.projectDir.path + '/modules/*/src/main/java'

// Return a list containing the --upgrade-module-path or --module-path
// used with Javac
List<String> computeModulePathArgs(String  pname, List<String> deps, boolean test) {
    List<String> mpa = HAS_JAVAFX_MODULES ? [ '--upgrade-module-path' ] : [ '--module-path' ]
    String mp = null
    deps.each { String projname ->
        def proj = project(projname)
        // for a non test set of args, we don't want the current module in the list
        // for a test test, we do need it to update what we built

        if (proj.hasProperty("moduleName") &&
                proj.buildModule &&
                !(!test && proj.name.equals(pname))) {

            File dir = new File(proj.sourceSets.main.java.outputDir, proj.ext.moduleName)
            if (mp == null) {
                mp = dir.path
            } else {
                mp = mp + File.pathSeparator + dir.path
            }
        }
    }

    // in some cases like base we could end up with an empty
    // path... make sure we don't pass one back
    if (mp == null) {
        return null
    }

    mpa += mp

    if (!HAS_JAVAFX_MODULES) {
        String addm = null
        deps.each {String projname ->
            def proj = project(projname)
            // for a non test set of args, we don't want the current module in the list
            // for a test test, we do need it to update what we built

            if (proj.hasProperty("moduleName") &&
                    proj.buildModule &&
                    !(!test && proj.name.equals(pname))) {

                if (addm == null) {
                    addm = proj.moduleName
                } else {
                    addm = addm + "," + proj.moduleName
                }
            }
        }
        if (addm != null) {
            mpa += "--add-modules=${addm}"
        }
    }

    return mpa
}

/**
 * Manages the execution of some closure which is responsible for producing
 * content for a properties file built at build time and stored in the
 * root project's $buildDir, and then loading that properties file and
 * passing it to the processor closure.
 *
 * This is used on windows to produce a properties file containing all the
 * windows visual studio paths and environment variables, and on Linux
 * for storing the results of pkg-config calls.
 *
 * @param name the name of the file to produce
 * @param loader a closure which is invoked, given the properties file. This
 *        closure is invoked only if the properties file needs to be created
 *        and is responsible for populating the properties file.
 * @param processor a closure which is invoked every time this method is
 *        called and which will be given a Properties object, fully populated.
 *        The processor is then responsible for doing whatever it is that it
 *        must do with those properties (such as setting up environment
 *        variables used in subsequent native builds, or whatnot).
 */
void setupTools(String name, Closure loader, Closure processor) {
    // Check to see whether $buildDir/$name.properties file exists. If not,
    // then generate it. Once generated, we need to read the properties file to
    // help us define the defaults for this block of properties
    File propFile = file("$buildDir/${name}.properties")
    if (!propFile.exists()) {
        // Create the properties file
        propFile.getParentFile().mkdirs()
        propFile.createNewFile()
        loader(propFile)
    }

    // Try reading the properties in order to define the properties. If the property file cannot
    // be located, then we will throw an exception because we cannot guess these values
    InputStream propStream = null
    try {
        Properties properties = new Properties()
        propStream = new FileInputStream(propFile)
        properties.load(propStream)
        processor(properties)
    } finally {
        try { propStream.close() } catch (Exception e) { }
    }
}

/**
 * If the given named property is not defined, then this method will define
 * it with the given defaultValue. Any properties defined by this method can
 * be substituted on the command line by using -P, or by specifying a
 * gradle.properties file in the user home dir
 *
 * @param name The name of the property to define
 * @param defaultValue The default value to assign the property
 */
void defineProperty(String name, String defaultValue) {
    if (!project.hasProperty(name)) {
        project.ext.set(name, defaultValue)
    }
}

/**
 * If the given named property is not defined, then this method will attempt to
 * look up the property in the props map, and use the defaultValue if it cannot be found.
 *
 * @param name The name of the property to look up and/or define
 * @param props The properties to look for the named property in, if it has not already been defined
 * @param defaultValue The default value if the property has not been defined and the
 *                     props map does not contain the named property
 */
void defineProperty(String name, Properties props, String defaultValue) {
    if (!project.hasProperty(name)) {
        project.ext.set(name, props.getProperty(name, defaultValue))
    }
}

// perform common project manipulation for modules
void commonModuleSetup(Project p, List<String> moduleChain) {

    p.ext.moduleChain = moduleChain

    if (p.hasProperty("moduleName")) {
        p.ext.moduleDir = new File(p.sourceSets.main.java.outputDir, "${p.moduleName}")
    }

    def mpa = computeModulePathArgs(p.name, moduleChain, false)
    if (mpa != null) {
        p.ext.modulePathArgs = mpa
    }

    p.ext.testModulePathArgs = computePatchModuleArgs(moduleChain, true)
    p.ext.patchModuleArgs = computePatchModuleArgs(moduleChain ,false)
    p.ext.testPatchModuleArgs = computePatchModuleArgs(moduleChain, true)

    moduleChain.each() {e ->
        if (!e.equals(p.name)) {
            p.compileJava.dependsOn(project(e).classes)
            p.compileTestJava.dependsOn(project(e).testClasses)
        }
    }
}

// Return list with the arguments needed for --patch-module or --module-path
// for the provided projects. Used with Java executables ie. tests
List<String> computePatchModuleArgs(List<String> deps, boolean test) {
    List<String> pma = []

    if (HAS_JAVAFX_MODULES) {
        deps.each { String projname ->
            def proj = project(projname)
            if (proj.hasProperty("moduleName")) {
                File dir = file("${rootProject.buildDir}/modular-sdk/modules")
                String moduleName = proj.ext.moduleName
                String dirpath = "${dir}/${moduleName}"
                pma += "--patch-module=${moduleName}=${dirpath}"
            }
        }
    } else {
        String mp = null
        deps.each { String projname ->
            def proj = project(projname)
            if (proj.hasProperty("moduleName")) {
                String moduleName = proj.ext.moduleName
                File dir = file("${rootProject.buildDir}/sdk/lib/${moduleName}.jar")
                if (mp == null) {
                    mp = dir.path
                } else {
                    mp = mp + File.pathSeparator + dir.path
                }
            }
        }

        // in some cases like base we could end up with an empty
        // path... make sure we don't pass one back
        if (mp == null) {
            return null
        }

        pma += '--module-path'
        pma += mp

        String addm = null
        deps.each {String projname ->
            def proj = project(projname)
            if (proj.hasProperty("moduleName") && proj.buildModule) {
                if (addm == null) {
                    addm = proj.moduleName
                } else {
                    addm = addm + "," + proj.moduleName
                }
            }
        }
        if (addm != null) {
            pma += "--add-modules=${addm}"
        }
    }

    return pma
}

project(":fxpackagerservices") {
    apply plugin: 'java'
    project.ext.buildModule = true
    project.ext.moduleName = "com.brcolow.packager.services"

    sourceSets {
        main {
            java {
                srcDirs = ['src/main/java']
            }
        }
    }

    project.ext.moduleSourcePath = defaultModuleSourcePath

    if (project.hasProperty("moduleName")) {
        project.ext.moduleDir = new File(project.sourceSets.main.java.outputDir, "${project.moduleName}")
    }
}

project(":fxpackager") {
    apply plugin: 'java'
    // apply plugin: 'checkstyle'

    project.ext.buildModule = true
    project.ext.moduleName = "com.brcolow.javapackager"
    project.ext.moduleSourcePath = defaultModuleSourcePath

    sourceSets {
        main {
            java {
                srcDirs = ['src/main/java']
            }
        }
        test {
            java {
                srcDirs = ['src/test/java']
            }
            resources {
                srcDirs = ['src/test/resources', "$projectDir/build/tmp/tests/appResources"]
            }
        }
    }

    jar {
        from "$buildDir/generated-resources"
    }

//    checkstyle {
//        configFile = rootProject.file("gradle/check/checkstyle.xml")
//        showViolations = true
//        ignoreFailures = false
//        toolVersion = "8.13"
//    }
//
//    // Decrease verbosity (printing of XSL style sheets, etc.)
//    [checkstyleMain, checkstyleTest].each { task ->
//        task.logging.setLevel(LogLevel.LIFECYCLE)
//    }
//
//    // exclude module info files for Java 9
//    checkstyleMain.exclude "**/module-info.java"
//    checkstyleTest.exclude "**/module-info.java"

    commonModuleSetup(project, [ 'fxpackagerservices', 'fxpackager' ])

    manifest {
        attributes(
                "Main-Class": "com.sun.openjfx.tools.packager.Main"
        )
    }

    repositories {
        mavenCentral()
    }

    dependencies {
        compile "org.openjfx:javafx-base:11:${PLATFORM}"
        compile "org.openjfx:javafx-graphics:11:${PLATFORM}"
        compile "org.openjfx:javafx-controls:11:${PLATFORM}"
        compile group: 'org.bouncycastle', name: 'bcprov-jdk15on', version: '1.60'
        compile group: 'org.bouncycastle', name: 'bcpkix-jdk15on', version: '1.60'
        testCompile group: "junit", name: "junit", version: "4.12"
        testCompile group: "com.github.stefanbirkner", name: "system-rules", "version": "1.18.0"
        testCompile group: 'org.apache.ant', name: 'ant', version: '1.10.5'
        testCompile project(":fxpackager")
    }

    compileJava {
        inputs.property("moduleName", moduleName)
        doFirst {
            options.compilerArgs = [
                    '--module-path', classpath.asPath,
                    '--add-modules', 'javafx.controls',
                    '--add-modules', 'javafx.graphics',
                    "--add-exports=java.base/sun.security.timestamp=${project.ext.moduleName}",
                    "--add-exports=java.base/sun.security.x509=${project.ext.moduleName}",
                    "--add-exports=java.base/sun.security.pkcs=${project.ext.moduleName}",
                    "--add-exports=jdk.jlink/jdk.tools.jlink.internal.packager=${project.ext.moduleName}",
                    "--add-exports=java.logging/java.util.logging=${project.ext.moduleName}",
            ]
            classpath = files()
        }
        options.encoding = 'UTF-8'
    }

    // The "man" task will create a $buildDir/man containing the man
    // files for the system being built
    task man(type: Copy) {
        includeEmptyDirs = false
        enabled = IS_LINUX || IS_MAC
        from "src/main/man"
        into "$buildDir/man"
        exclude "**/*.html"
    }

    processResources.dependsOn man

    if (IS_WINDOWS) {
        setupTools("windows_tools",
            { propFile ->
                // Create the properties file
                ByteArrayOutputStream results = new ByteArrayOutputStream()
                String winsdkDir = System.getenv().get("WINSDK_DIR")
                exec({
                    environment([
                            "WINSDKPATH" : winsdkDir == null ? "" : winsdkDir,
                            "CONF"       : "/$CONF", // TODO does this mean the generated properties must be reset when in a different configuration?
                            "VCARCH"     : IS_64 ? "amd64" : "x86",
                            "SDKARCH"    : IS_64 ? "/x64" : "/x86",
                    ])
                    commandLine("cmd", "/q", "/c", "buildSrc\\genVSproperties.bat")
                    setStandardOutput(results)
                })
                BufferedReader reader = new BufferedReader(new StringReader(results.toString().trim()))
                reader.readLine()
                reader.readLine()
                String line
                while ((line = reader.readLine()) != null && !line.startsWith("######")) {
                    line = line.replace("\\", "/").replace("/@@ENDOFLINE@@", "").replace("@@ENDOFLINE@@", "").replace("//", "/").replace("windows.vs.", "WINDOWS_VS_")
                    propFile << line << "\r\n"
                }
            },
            { properties ->
                defineProperty("WINDOWS_VS_VSINSTALLDIR", properties, "c:/Program Files (x86)/Microsoft Visual Studio/2017/Professional")
                defineProperty("WINDOWS_VS_WINSDKDLLINSTALLDIR", properties, "c:/Program Files (x86)/Windows Kits/10/Redist/ucrt/DLLs")
                defineProperty("WINDOWS_SDK_DIR", properties, System.getenv().get("WINSDK_DIR"))
                defineProperty("WINDOWS_SDK_VERSION", properties, "")
                defineProperty("WINDOWS_VS_VCINSTALLDIR", properties, "$WINDOWS_VS_VSINSTALLDIR/VC")
                defineProperty("WINDOWS_VS_DEVENVDIR", properties, "$WINDOWS_VS_VSINSTALLDIR/Common7/IDE")
                defineProperty("WINDOWS_VS_DEVENVCMD", properties, "$WINDOWS_VS_DEVENVDIR/VCExpress.exe")
                defineProperty("WINDOWS_VS_MSVCDIR", properties, WINDOWS_VS_VCINSTALLDIR)
                defineProperty("WINDOWS_DXSDK_DIR", properties, System.getenv().get("DXSDK_DIR"))
                defineProperty("WINDOWS_VS_INCLUDE", properties, "$WINDOWS_VS_VCINSTALLDIR/INCLUDE;" + "$WINDOWS_SDK_DIR/include;")
                defineProperty("WINDOWS_VS_VER", properties, "150")
                defineProperty("WINDOWS_VS_LIB", properties, "$WINDOWS_VS_VCINSTALLDIR/LIB;" + "$WINDOWS_SDK_DIR/lib;")
                defineProperty("WINDOWS_VS_LIBPATH", properties, "$WINDOWS_VS_VCINSTALLDIR/LIB;")
                defineProperty("WINDOWS_VS_PATH", properties, "$WINDOWS_VS_DEVENVDIR;" +
                        "$WINDOWS_VS_VSINSTALLDIR/VC/BIN;" +
                        "$WINDOWS_VS_VSINSTALLDIR/Common7/Tools;" +
                        "$WINDOWS_VS_VCINSTALLDIR/VCPackages;" +
                        "$WINDOWS_SDK_DIR/bin/NETFX 4.0 Tools;" +
                        "$WINDOWS_SDK_DIR/bin;" +
                        System.getenv().get("PATH"))
            }
        )

        def winVsVer = Integer.parseInt(WINDOWS_VS_VER)
        if (WINDOWS_SDK_DIR == null || WINDOWS_SDK_DIR == "") {
            // Skip so IDEs can configure project.
            // throw new GradleException("FAIL: WINSDK_DIR not defined")
        }

        def msvcVer = System.getenv("MSVC_VER") ?: "14.10.25017"
        def msvcBinDir = ""
        if (winVsVer == 150) {
            msvcBinDir = (IS_64
                    ? "$WINDOWS_VS_VSINSTALLDIR/VC/Tools/MSVC/$msvcVer/bin/HostX64/x64"
                    : "$WINDOWS_VS_VSINSTALLDIR/VC/Tools/MSVC/$msvcVer/bin/HostX86/x86")
        } else if (winVsVer <= 120) {
            msvcBinDir = (IS_64
                    ? "$WINDOWS_VS_VSINSTALLDIR/VC/BIN/amd64"
                    : "$WINDOWS_VS_VSINSTALLDIR/VC/BIN")
        }

        // Define set of flags shared for all targets that support debug compilation
        def ccDebugFlags = IS_DEBUG_NATIVE ? ["/MDd", "/Od", "/Zi", "/DDEBUG"] : ["/O2", "/MD", "/DNDEBUG"]

        ext.WINDOWS_NATIVE_COMPILE_ENVIRONMENT = [
                "VCINSTALLDIR"         : WINDOWS_VS_VCINSTALLDIR,
                "VSINSTALLDIR"         : WINDOWS_VS_VSINSTALLDIR,
                "DEVENVDIR"            : WINDOWS_VS_DEVENVDIR,
                "MSVCDIR"              : WINDOWS_VS_MSVCDIR,
                "VS_VER"               : WINDOWS_VS_VER,
                "PATH"                 : WINDOWS_VS_PATH,
                "INCLUDE"              : WINDOWS_VS_INCLUDE,
                "LIB"                  : WINDOWS_VS_LIB,
                "LIBPATH"              : WINDOWS_VS_LIBPATH,
                "DXSDK_DIR"            : WINDOWS_DXSDK_DIR
        ]

        def winSdkBinDir = "$WINDOWS_SDK_DIR/Bin"
        if (WINDOWS_VS_VER != "100") {
            winSdkBinDir += "/" + (IS_64 ? "x64" : "x86")
        }

        if (!file("$winSdkBinDir/RC.Exe").exists()) {
            winSdkBinDir = "$WINDOWS_SDK_DIR/Bin/$WINDOWS_SDK_VERSION"
            if (WINDOWS_VS_VER != "100") {
                winSdkBinDir += "/" + (IS_64 ? "x64" : "x86")
            }
        }
        println "winSdkBinDir=$winSdkBinDir"
        ext.RC = "${winSdkBinDir}/rc.exe"
        ext.MC = "${winSdkBinDir}/mt.exe"
        def rcCompiler = RC

        // Skip so IDEs can configure project.
        // if (!file(RC).exists()) throw new GradleException("FAIL: cannot find RC: " + RC)

        def msvcRedistVer = System.getenv("MSVC_REDIST_VER") ?: "14.10.25008"
        String msvcRedstDir = (IS_64
                ? "$WINDOWS_VS_VSINSTALLDIR/VC/Redist/MSVC/$msvcRedistVer/x64"
                : "$WINDOWS_VS_VSINSTALLDIR/VC/Redist/MSVC/$msvcRedistVer/x86")
        def WINDOWS_DLL_VER = WINDOWS_VS_VER
        ext.MSVCR = null
        ext.MSVCP = null

        def windowsCRTVer = System.getenv("WINDOWS_CRT_VER") ?: "150"
        if (WINDOWS_VS_VER == "150") {
            WINDOWS_DLL_VER = "140"
            ext.MSVCR = "${msvcRedstDir}/Microsoft.VC${windowsCRTVer}.CRT/vcruntime${WINDOWS_DLL_VER}.dll"
            ext.MSVCP = "${msvcRedstDir}/Microsoft.VC${windowsCRTVer}.CRT/msvcp${WINDOWS_DLL_VER}.dll"
        }
        // Product version variables passed to RC:
        def rcVer = "0.0.1"
        def rcVerMajor = 0
        def rcVerMinor = 0
        def rcVerSecurity = 0
        def rcVerPatch = 1
        def rcVerFile = "${rcVerMajor},${rcVerMinor},${rcVerSecurity},${rcVerPatch}"
        def rcVerBuild = "0.0.1"
        def rcVerCopyrYear = "${Calendar.getInstance().get(Calendar.YEAR)}"
        def rcFlags = [
                "/d", "\"JFX_COMPANY=${COMPANY_NAME}\"",
                "/d", "\"JFX_COMPONENT=${PRODUCT_NAME} ${PLATFORM_NAME} binary\"",
                "/d", "\"JFX_NAME=${PRODUCT_NAME} ${PLATFORM_NAME} ${rcVerMajor}\"",
                "/d", "\"JFX_VER=${rcVer}\"",
                "/d", "\"JFX_BUILD_ID=${rcVerBuild}\"",
                "/d", "\"JFX_COPYRIGHT=Copyright \u00A9 ${rcVerCopyrYear}\"",
                "/d", "\"JFX_FVER=${rcVerFile}\"",
                "/d", "\"JFX_FTYPE=0x2L\"",
                "/nologo"
        ]

        ext.WIN = [:]
        WIN.launcher = [:]
        WIN.launcher.ccFlags = ["/nologo", "/W3", "/MT", "/EHsc", "/D_WINDOWS", "/DUNICODE", "/D_UNICODE", "/DWIN32",
                                "/D_LITTLE_ENDIAN", "/DWIN32_LEAN_AND_MEAN", "/I$JDK_HOME/include", "/I$JDK_HOME/include/win32",
                                ccDebugFlags].flatten()
        WIN.launcher.linkFlags = ["/link", "/nologo", "/WX", "/SUBSYSTEM:WINDOWS", "user32.lib", "shell32.lib", "advapi32.lib"]
        if (IS_DEBUG_NATIVE) WIN.launcher.linkFlags.add("/debug")

        WIN.launcherlibrary = [:]
        WIN.launcherlibrary.ccFlags = ["/nologo", "/W3", "/FS",
                                       // "/WX",
                                       "/EHsc", "/c", "/D_WINDOWS", "/DUNICODE", "/D_UNICODE", "/DWIN32",
                                       "/D_LITTLE_ENDIAN", "/DWIN32_LEAN_AND_MEAN", "/I$JDK_HOME/include", "/I$JDK_HOME/include/win32",
                                       ccDebugFlags].flatten()
        WIN.launcherlibrary.linkFlags = ["/nologo", "/WX", "/DLL", "/SUBSYSTEM:WINDOWS", "user32.lib", "shell32.lib", "advapi32.lib", "ole32.lib"]
        if (IS_DEBUG_NATIVE) WIN.launcherlibrary.linkFlags.add("/debug")

        WIN.fxpackager = [:]
        WIN.fxpackager.nativeSource = [file("src/main/native/javapackager/win")]
        WIN.fxpackager.ccFlags = ["/nologo", "/W3", "/EHsc", "/MT", "/GS",  "/DUNICODE", "/D_UNICODE",
                            "/DWIN32", "/D_LITTLE_ENDIAN", "/DWIN32_LEAN_AND_MEAN",
                            "/D_WIN32_WINDOWS=0X0500", "/D_WIN32_WINNT=0X0500",
                            "/I$JDK_HOME/include", "/I$JDK_HOME/include/win32",
                            "/O2", "-c"]
        WIN.fxpackager.linkFlags = ["/nologo", "/SUBSYSTEM:CONSOLE", "/opt:REF", "/incremental:no", "/manifest", "kernel32.lib", "advapi32.lib"]
        WIN.fxpackager.rcSource = file("src/main/native/javapackager/win/javapackager.rc")
        WIN.fxpackager.rcCompiler = rcCompiler
        WIN.fxpackager.rcFlags = [
            "/l", "0x409",
            "/d", "JFX_FNAME=javapackager.exe",
            "/d", "JFX_INTERNAL_NAME=javapackager",
        rcFlags].flatten()

        task buildWinLauncher(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher"
            matches = "WinLauncher\\.cpp"
            params.addAll(WIN.launcher.ccFlags)
            output(file("$buildDir/native/WinLauncher"))
            source(file("src/main/native/launcher/win"))
            compiler = "${msvcBinDir}/cl.exe"
            exe = true
            linkerOptions.addAll(WIN.launcher.linkFlags)
        }

        task copyWinLauncher(type: Copy, group: "Build", dependsOn: buildWinLauncher) {
            from "$buildDir/native/WinLauncher/WinLauncher.exe"
            from "$MSVCR"
            from "$MSVCP"
            into "${buildDir}/generated-resources/com/sun/openjfx/tools/packager/windows"
        }

        task compileWinLibrary(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher library"
            matches = ".*\\.cpp"
            source(file("src/main/native/library/common"))
            params.addAll(WIN.launcherlibrary.ccFlags)
            output(file("$buildDir/native/WinLauncher/obj"))
            compiler = "${msvcBinDir}/cl.exe"
        }

        task linkWinLibrary(type: LinkTask, group: "Build", dependsOn: compileWinLibrary) {
            description = "Links native sources for the application co-bundle launcher library"
            objectDir = file("$buildDir/native/WinLauncher/obj")
            linkParams.addAll(WIN.launcherlibrary.linkFlags)
            lib = file("$buildDir/native/WinLauncher/packager.dll")
            linker = "${msvcBinDir}/link.exe"
        }

        task copyWinLibrary(type: Copy, group: "Build", dependsOn: linkWinLibrary) {
            from "$buildDir/native/WinLauncher/packager.dll"
            into "${buildDir}/generated-resources/com/sun/openjfx/tools/packager/windows"
        }

        task buildWinLauncherSvc(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher"
            matches = "WinLauncherSvc\\.cpp"
            params.addAll(WIN.launcher.ccFlags)
            output(file("$buildDir/native/WinLauncherSvc"))
            source(file("src/main/native/service/win"))
            compiler = "${msvcBinDir}/cl.exe"
            exe = true
            linkerOptions.addAll(WIN.launcher.linkFlags)
        }

        task copyWinLauncherSvc(type: Copy, group: "Build", dependsOn: buildWinLauncherSvc) {
            from "$buildDir/native/WinLauncherSvc/WinLauncherSvc.exe"
            into "${buildDir}/generated-resources/com/sun/openjfx/tools/packager/windows"
        }

        task compileLauncher(dependsOn: [copyWinLauncher, copyWinLibrary, copyWinLauncherSvc])

        task setupCompileJavaPackager(type: Copy, group: "Build") {
            mkdir "$buildDir/native"
            mkdir "$buildDir/native/javapackager"
            from file("src/main/native/javapackager/win/javapackager.manifest")
            into file("$buildDir/native/javapackager")
            filter { line ->
                line = line.replace("FXVERSION", "0.0.0.1")
            }
        }

        task compileJavaPackager(type: CCTask, group: "Build", dependsOn: setupCompileJavaPackager) {
            description = "Compiles native sources for javapackager.exe"
            matches = ".*\\.cpp"
            params.addAll(WIN.fxpackager.ccFlags)
            compiler = "${msvcBinDir}/cl.exe"
            output(file("$buildDir/native/javapackager/obj"))
            source WIN.fxpackager.nativeSource
            doLast {
                mkdir "$buildDir/native"
                exec {
                    environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
                    commandLine(WIN.fxpackager.rcCompiler)
                    args(WIN.fxpackager.rcFlags)
                    args("/fo$buildDir/native/javapackager/javapackager.res")
                    args(WIN.fxpackager.rcSource)
                }
            }
        }

        task linkJavaPackager(type: LinkTask, dependsOn: compileJavaPackager, group: "Build") {
            description = "Links javapackager.exe"
            objectDir = file("$buildDir/native/javapackager/obj")
            linkParams.addAll(WIN.fxpackager.linkFlags)
            lib = file("$buildDir/native/javapackager/javapackager.exe")
            linker = "${msvcBinDir}/link.exe"
            doLast {
                exec({
                    commandLine("$MC", "-manifest",
                            "$buildDir/native/javapackager/javapackager.manifest",
                            "-outputresource:$buildDir/native/javapackager/javapackager.exe")
                    environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
                })
            }
        }

        task copyJavaPackager(type: Copy, group: "Build", dependsOn: linkJavaPackager) {
            from file("$buildDir/native/javapackager/javapackager.exe")
            into file("$buildDir/generated-resources/com/sun/openjfx/tools/packager/windows/javapackager.exe")
        }

        task buildJavaPackager(dependsOn: [copyJavaPackager])
    } else if (IS_LINUX) {
        ext.LINUX = [:]
        LINUX.launcher = [:]
        LINUX.launcher.ccFlags = ["-Wextra", "-Wformat", "-Wformat-security", "-DJAVAARCH=\"$OS_ARCH\"", "-I$JDK_HOME/include", "-I$JDK_HOME/include/linux", "-c"]
        LINUX.launcher.linkFlags = ["-ldl"]
        if (!IS_64) {
            LINUX.launcher.ccFlags += "-m32"
            LINUX.launcher.linkFlags += "-m32"
        }
        LINUX.launcherlibrary = [:]
        LINUX.launcherlibrary.ccFlags = ["-Wextra", "-Wformat", "-Wformat-security", "-DJAVAARCH=\"$OS_ARCH\"", "-I$JDK_HOME/include", "-I$JDK_HOME/include/linux", "-c", "-fPIC"]
        LINUX.launcherlibrary.linkFlags = ["-ldl", "-lpthread", "-shared"]
        if (!IS_64) {
            LINUX.launcherlibrary.ccFlags += "-m32"
            LINUX.launcherlibrary.linkFlags += "-m32"
        }

        task compileLinuxLauncher(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher"
            matches = ".*\\.cpp"
            source file("src/main/native/launcher/linux")
            params.addAll(LINUX.launcher.ccFlags)
            compiler = "gcc"
            output(file("$buildDir/native/linuxlauncher/launcherobj"))
        }

        task linkLinuxLauncher(type: LinkTask, dependsOn: compileLinuxLauncher, group: "Build") {
            description = "Links native dynamic library for the application co-bundle launcher"
            objectDir = file("$buildDir/native/linuxlauncher/launcherobj")
            linkParams.addAll(LINUX.launcher.linkFlags)
            linker = "g++"
            lib = file("${buildDir}/generated-resources/com/sun/openjfx/tools/packager/linux/JavaAppLauncher")
        }

        task compileLinuxLibrary(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher library"
            matches = ".*\\.cpp"
            source file("src/main/native/library/common")
            params.addAll(LINUX.launcherlibrary.ccFlags)
            compiler = "gcc"
            output(file("$buildDir/native/linuxlauncher/obj"))
        }

        task linkLinuxLibrary(type: LinkTask, dependsOn: compileLinuxLibrary, group: "Build") {
            description = "Links native dynamic library for the application co-bundle launcher library"
            objectDir = file("$buildDir/native/linuxlauncher/obj")
            linkParams.addAll(LINUX.launcherlibrary.linkFlags)
            linker = "g++"
            lib = file("${buildDir}/generated-resources/com/sun/openjfx/tools/packager/linux/libpackager.so")
        }

        task compileLauncher(dependsOn: [linkLinuxLauncher, linkLinuxLibrary])
    } else if (IS_MAC) {
        clean {
            delete "${buildDir}/mac_tools.properties"
        }
        /*
         * Define settings for Mac compilation. If we don't find the preferred SDK
         * in the default location then we will use "xcodebuild" to locate a suitable SDK.
         * In extreme cases you can provide your own properties in your home dir to
         * override these settings or pass them on the command line.
         */
        def prefSdkVersion = "10.9"
        def defaultSdkPath = "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX${prefSdkVersion}.sdk"

        // Set the minimum API version that we require (developers do not need to override this)
        // Note that this is not necessarily the same as the preferred SDK version
        defineProperty("MACOSX_MIN_VERSION", "10.9")

        // Create $buildDir/mac_tools.properties file and load props from it
        setupTools("mac_tools",
                { propFile ->
                    propFile << ""
                    if (!file(defaultSdkPath).isDirectory()) {
                        // Get list of all macosx sdks
                        ByteArrayOutputStream results = new ByteArrayOutputStream()
                        exec {
                            commandLine("xcodebuild", "-version", "-showsdks")
                            setStandardOutput(results)
                        }

                        BufferedReader reader = new BufferedReader(new StringReader(results.toString().trim()))
                        // If our preferred SDK is in the list use it, else use the default
                        String sdk = "macosx"
                        String prefSdk = sdk + prefSdkVersion
                        while (true) {
                            def line = reader.readLine()
                            if (line == null) break
                            if (line.contains("-sdk ${prefSdk}")) {
                                sdk = prefSdk
                                break
                            }
                        }

                        results = new ByteArrayOutputStream()
                        exec {
                            commandLine("xcodebuild", "-version", "-sdk", sdk, "Path")
                            setStandardOutput(results)
                        }
                        String sdkPath = results.toString().trim()
                        propFile << "MACOSX_SDK_PATH=" << sdkPath << "\n"
                    }
                },
                { properties ->
                    defineProperty("MACOSX_SDK_PATH", properties, defaultSdkPath)
                }
        )
        println "MACOSX_MIN_VERSION = $MACOSX_MIN_VERSION"
        println "MACOSX_SDK_PATH = $MACOSX_SDK_PATH"

        if (!file(MACOSX_SDK_PATH).isDirectory()) {
            if (!gradle.startParameter.taskNames.contains("clean")) {
                if (file("./build/mac_tools.properties").exists()) {
                    logger.warn("If you upgraded XCode you must run 'clean' to regenerate the properties fie.")
                }
                throw new GradleException("FAIL: Cannot find $MACOSX_SDK_PATH")
            }
        }

        // NOTE: There is no space between -iframework and the specified path
        def commonParams = [
                "-mmacosx-version-min=$MACOSX_MIN_VERSION",
                "-isysroot", "$MACOSX_SDK_PATH",
                "-iframework$MACOSX_SDK_PATH/System/Library/Frameworks",
                "-arch", "x86_64"]

        def ccBaseFlags = [
                commonParams,
                "-I$JDK_HOME/include",
                "-I$JDK_HOME/include/darwin"].flatten()
        ext.MAC = [:]
        MAC.launcher = [:]
        MAC.launcher.ccFlags = [
                "-std=c99",
                ccBaseFlags,
                "-framework", "Cocoa",
                IS_DEBUG_NATIVE ? ["-DDEBUG", "-O0"] : ["-O3", "-DNDEBUG"]].flatten()
        MAC.launcher.linkFlags = ["-ldl"]

        MAC.launcherlibrary = [:]
        MAC.launcherlibrary.ccFlags = [
                "-c",
                ccBaseFlags,
                IS_DEBUG_NATIVE ? ["-DDEBUG", "-O0"] : ["-O3", "-DNDEBUG"]].flatten()
        MAC.launcherlibrary.ccFlags += "-stdlib=libc++"
        MAC.launcherlibrary.linkFlags = ["-ldl", "-dynamiclib",
                                         "-framework", "Cocoa",
                                         "-stdlib=libc++"]

        task buildMacLauncher(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher"
            matches = ".*\\.m"
            source file("src/main/native/launcher/mac")
            params.addAll(MAC.launcher.ccFlags)
            compiler = "clang"
            output(file("${buildDir}/generated-resources/com/sun/openjfx/tools/packager/mac"))
            outputs.file(file("${buildDir}/generated-resources/com/sun/openjfx/tools/packager/mac/JavaAppLauncher"))
            eachOutputFile = { f ->
                return new File(f.getParent(), "JavaAppLauncher")
            }
        }

        task compileMacLibrary(type: CCTask, group: "Build") {
            description = "Compiles native sources for the application co-bundle launcher library"
            matches = ".*\\.cpp|.*\\.mm"
            source file("src/main/native/library/common")
            params.addAll(MAC.launcherlibrary.ccFlags)
            compiler = "clang"
            output(file("$buildDir/native/maclauncher/obj"))
        }

        task linkMacLibrary(type: LinkTask, group: "Build", dependsOn: compileMacLibrary) {
            description = "Links native sources for the application co-bundle launcher library"
            objectDir = file("$buildDir/native/maclauncher/obj")
            linkParams.addAll(MAC.launcherlibrary.linkFlags)
            linker = "clang++"
            lib = file("${buildDir}/generated-resources/com/sun/openjfx/tools/packager/mac/libpackager.dylib")
        }

        task compileLauncher(dependsOn: [buildMacLauncher, linkMacLibrary])
    }

    // Builds the javapackager executable. For everything other than windows,
    // this is simply moving the existing shell script and ensuring it has proper
    // permissions. For Windows, this includes compiling the native executable
    if (!IS_WINDOWS) {
        task buildJavaPackager(type: Copy, group: "Build") {
            enabled = true
            from "src/main/native/javapackager/shell"
            into "$buildDir/javapackager"
            fileMode = 0755
        }
    }

    assemble.dependsOn compileLauncher
    assemble.dependsOn buildJavaPackager

    task setupPackagerFakeJar(type: Copy) {
        from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/linux/javalogo_white_48.png"
        from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/mac/GenericAppHiDPI.icns"
        from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/windows/javalogo_white_48.ico"
        from "$projectDir/src/test/resources/hello/java-logo2.gif"
        from "$projectDir/src/test/resources/hello/small.ico"
        from "$projectDir/src/test/resources/hello/test.icns"
        from "$projectDir/src/test/resources/hello/LICENSE-RTF.rtf"
        into project.file("$projectDir/build/tmp/tests/appResources")
    }

    task packagerFakeJar(type: Jar, dependsOn: [setupPackagerFakeJar]) {
        dependsOn compileTestJava
        from compileTestJava.destinationDir
        include "hello/**"

        destinationDir project.file("build/tmp/tests/appResources")
        archiveName "mainApp.jar"

        manifest {
            attributes(
                    "Main-Class": "hello.HelloRectangle",
                    "Custom-Attribute": " Is it stripped?"
            )
        }

        doFirst {
            copy {
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/linux/javalogo_white_16.png"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/linux/javalogo_white_32.png"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/linux/javalogo_white_48.png"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/mac/GenericAppHiDPI.icns"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/windows/javalogo_white_48.ico"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/linux/template.control"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/linux/template.copyright"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/linux/template.deb.init.script"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/linux/template.desktop"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/linux/template.postinst"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/linux/template.postrm"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/linux/template.preinst"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/linux/template.prerm"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/linux/template.rpm.init.script"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/linux/template.spec"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/mac/background_dmg.png"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/mac/background_pkg.png"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/mac/DMGsetup.scpt"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/mac/GenericApp.icns"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/mac/GenericAppHiDPI.icns"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/mac/Info.plist.template"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/mac/Info-lite.plist.template"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/mac/launchd.plist.template"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/mac/lic_template.plist"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/mac/MacAppStore.entitlements"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/mac/MacAppStore_Inherit.entitlements"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/mac/postinstall.template"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/mac/preinstall.template"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/mac/Runtime-Info.plist.template"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/windows/icon_inno_setup.bmp"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/windows/javalogo_white_16.ico"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/windows/javalogo_white_32.ico"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/windows/javalogo_white_48.ico"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/windows/template.iss"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/windows/template.wxs"
                from "$projectDir/src/main/resources/com/sun/openjfx/tools/packager/windows/WinLauncher.properties"
                from "$projectDir/src/test/resources/hello/java-logo2.gif"
                from "$projectDir/src/test/resources/hello/small.ico"
                from "$projectDir/src/test/resources/hello/test.icns"
                from "$projectDir/src/test/resources/hello/LICENSE-RTF.rtf"
                from "$projectDir/../../LICENSE"
                into project.file("$projectDir/build/tmp/tests/appResources")
            }
            copy {
                from "$projectDir/../../LICENSE"
                into project.file("$projectDir/build/tmp/tests/appResources")
                rename '(.*)LICENSE', '$1LICENSE2'
            }
        }
    }

    task packagerFXPackagedJar(type: Jar) {
        dependsOn packagerFakeJar
        from compileTestJava.destinationDir
        include "hello/**"

        destinationDir project.file("build/tmp/tests/appResources")
        archiveName "packagedMainApp.jar"

        manifest {
            attributes(
                    "JavaFX-Application-Class": "hello.TestPackager",
            )
        }
    }

    compileTestJava {
        exclude "hello/**"
        inputs.property("moduleName", project.ext.moduleName)
        doFirst {
            options.compilerArgs = [
                    '--module-path', classpath.asPath,
                    '--add-modules', 'junit',
                    '--add-reads', "${project.ext.moduleName}=junit",
                    "--add-exports", "jdk.jlink/jdk.tools.jlink.internal.packager=${project.ext.moduleName}",
                    '--patch-module', "${project.ext.moduleName}=" + files(sourceSets.test.java.srcDirs).asPath,
            ]
            classpath = files()
        }
    }

    test {
        inputs.property("moduleName", project.ext.moduleName)
        doFirst {
            jvmArgs = [
                    '--module-path', classpath.asPath,
                    "--add-exports", "java.base/sun.security.timestamp=${project.ext.moduleName}",
                    "--add-exports", "java.base/sun.security.x509=${project.ext.moduleName}",
                    "--add-exports", "java.base/sun.security.pkcs=${project.ext.moduleName}",
                    '--add-exports', "${project.ext.moduleName}/com.sun.openjfx.tools.packager.windows=junit",
                    '--add-exports', "${project.ext.moduleName}/com.sun.openjfx.tools.packager.mac=junit",
                    '--add-exports', "${project.ext.moduleName}/com.sun.openjfx.tools.packager.linux=junit",
                    '--add-exports', "jdk.jlink/jdk.tools.jlink.internal.packager=${project.ext.moduleName}",
                    '--add-modules', 'ALL-MODULE-PATH',
                    '--add-reads', "${project.ext.moduleName}=junit",
                    '--add-reads', "${project.ext.moduleName}=system.rules",
                    '--patch-module', "${project.ext.moduleName}=" + files(sourceSets.test.java.outputDir).asPath,
            ]
            classpath = files()
        }
        enableAssertions = true
        scanForTestClasses = false
        include("**/*Test.*")
        exclude("**/test/java/hello/*.java")
        testLogging {
            events TestLogEvent.STARTED, TestLogEvent.PASSED,
                    TestLogEvent.SKIPPED, TestLogEvent.FAILED,
                    TestLogEvent.STANDARD_OUT, TestLogEvent.STANDARD_ERROR
            showExceptions true
            exceptionFormat TestExceptionFormat.FULL
            showCauses true
            showStackTraces true

            info.events = debug.events
            def failedTestSummary = "\n\nFAILED TESTS SUMMARY: \n\n"
            afterTest { desc, result ->
                if (desc.parent) {
                    if (result.getResultType() == TestResult.ResultType.FAILURE) {
                        failedTestSummary += "${desc.getClassName()}#${desc.getName()} FAILED:\n" +
                                "${result.getExceptions()}\n"
                    }
                }
            }
            afterSuite { desc, result ->
                if (!desc.parent) { // will match the outermost suite
                    def output = "Results: ${result.resultType} (${result.testCount} tests, " +
                            "${result.successfulTestCount} successes, " +
                            "${result.failedTestCount} failures, " +
                            "${result.skippedTestCount} skipped)"
                    def startItem = '|  ', endItem = '  |'
                    def repeat = startItem + output + endItem
                    println('\n' + ('-' * repeat.length()) + '\n' + repeat + '\n' + ('-' * repeat.length()))
                    if (result.failedTestCount > 0) {
                        println(failedTestSummary)
                    }
                }
            }
        }

        dependsOn packagerFXPackagedJar
        systemProperty "RETAIN_PACKAGER_TESTS", RETAIN_PACKAGER_TESTS
        systemProperty "TEST_PACKAGER_DMG", TEST_PACKAGER_DMG
        systemProperty "FULL_TEST", FULL_TEST
    }

    def packagerDevOpts = []
    try {
        packagerDevOpts.addAll(PACKAGER_DEV_OPTS.split(' '))
    } catch (MissingPropertyException ignore) {
        packagerDevOpts.addAll("image")
    }

    task packagerDev(dependsOn: [jar, testClasses, packagerFakeJar], type : JavaExec) {
        workingDir = project.file("build/tmp/tests/appResources/")
        executable = JAVA
        classpath = project.files("build/classes/test", "build/resources/test")
        main = "hello.SimpleBundle"
        args = [
                '--module-path', JDK_JMODS,
                '-o', "$projectDir/build/dev",
                '-all',
                packagerDevOpts
        ].flatten()
    }

    task createPackagerServicesModule(type: Jar) {
        if (project.hasProperty("DEBUGJDK_HOME")) {
            def dir = file("$DEBUGJDK_HOME/newmodules")
            dir.mkdirs()

            includeEmptyDirs = false
            archiveName = "jdk.packager.services.jar"
            destinationDir = dir

            from (project.file("$rootProject.buildDir/modular-sdk/modules/jdk.packager.services")) {
                include "**"
            }

            from (project.file("$rootProject.buildDir/../modules/jdk.packager/build/classes/java/main/jdk.packager.services")) {
                include "module-info.class"
            }
        }
    }

    task createPackagerModule(type: Jar) {
        if (project.hasProperty("DEBUGJDK_HOME")) {
            def dir = file("$DEBUGJDK_HOME/newmodules")
            dir.mkdirs()

            includeEmptyDirs = false
            archiveName = "jdk.packager.jar"
            destinationDir = dir

            from (project.file("$rootProject.buildDir/modular-sdk/modules/jdk.packager")) {
                include "**"
            }

            from (project.file("$rootProject.buildDir/../modules/jdk.packager/build/classes/java/main/jdk.packager")) {
                include "module-info.class"
            }
        }
    }

    task createRunScript() {
        def TEXT = "DEBUG_ARG=\"-J-Xdebug:\"\n" +
                "\n" +
                "# Argument parsing.\n" +
                "ARGS=()\n" +
                "for i in \"\$@\"; do\n" +
                "    if [[ \"\$i\" == \${DEBUG_ARG}* ]]; then\n" +
                "        ADDRESS=\${i:\${#DEBUG_ARG}}\n" +
                "        DEBUG=\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=\${ADDRESS}\"\n" +
                "    else\n" +
                "        ARGS+=(\"\$i\")\n" +
                "    fi\n" +
                "done\n" +
                "\n" +
                "\${JAVA_HOME}/bin/java.original --upgrade-module-path \${JAVA_HOME}/newmodules \$(IFS=\$\' \'; echo \"\${ARGS[*]}\")\n"

        doLast {
            new File("$DEBUGJDK_HOME/bin").mkdirs()
            def runscript = new File("$DEBUGJDK_HOME/bin/java")
            runscript.write(TEXT)
        }

        doLast {
            exec {
                commandLine('chmod',  '+x', "$DEBUGJDK_HOME/bin/java")
            }
        }
    }

    task createBuildScript() {
        def TEXT = "DEBUG_ARG=\"-J-Xdebug:\"\n" +
                "\n" +
                "# Argument parsing.\n" +
                "ARGS=()\n" +
                "for i in \"\$@\"; do\n" +
                "    if [[ \"\$i\" == \${DEBUG_ARG}* ]]; then\n" +
                "        ADDRESS=\${i:\${#DEBUG_ARG}}\n" +
                "        DEBUG=\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=\${ADDRESS}\"\n" +
                "    else\n" +
                "        ARGS+=(\"\$i\")\n" +
                "    fi\n" +
                "done\n" +
                "\n" +
                "\${JAVA_HOME}/bin/javac.original --upgrade-module-path \${JAVA_HOME}/newmodules \$(IFS=\$\' \'; echo \"\${ARGS[*]}\")\n"

        doLast {
            new File("$DEBUGJDK_HOME/bin").mkdirs()
            def buildscript = new File("$DEBUGJDK_HOME/bin/javac")
            buildscript.write(TEXT)
        }

        doLast {
            exec {
                commandLine('chmod',  '+x', "$DEBUGJDK_HOME/bin/javac")
            }
        }
    }

    task createDebugJDK(dependsOn: [createPackagerModule, createPackagerServicesModule, createRunScript, createBuildScript]) {
        def EXE = IS_WINDOWS ? ".exe" : ""

        doLast {
            copy {
                from SOURCEJDK_HOME
                into DEBUGJDK_HOME
                exclude("*/javapackager$EXE")
                exclude("*/java$EXE")
                exclude("*/javac$EXE")
                exclude("*/jdk.packager.services.jmod")
            }

            copy {
                from "$SOURCEJDK_HOME/bin/java$EXE"
                into "$DEBUGJDK_HOME/bin"
                rename "java$EXE", "java.original$EXE"
            }

            copy {
                from "$SOURCEJDK_HOME/bin/javac$EXE"
                into "$DEBUGJDK_HOME/bin"
                rename "javac$EXE", "javac.original$EXE"
            }

            copy {
                from "$rootProject.buildDir/modular-sdk/modules_cmds/jdk.packager/javapackager$EXE"
                into "$DEBUGJDK_HOME/bin"
            }

            copy {
                from "$DEBUGJDK_HOME/newmodules/jdk.packager.services.jar"
                into "$DEBUGJDK_HOME/jmods"
            }
        }
    }

    task copyRedistributableFiles(type: Copy) {
        def sourceDir = "src/tools/java/legacy"
        def resourceDir = "src/main/resources/com/sun/openjfx"

        from "$sourceDir/jre.list"
        into project.file("$resourceDir")
    }

    processResources.dependsOn copyRedistributableFiles
}
